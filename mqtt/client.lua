--- MQTT client module
-- @module mqtt.client
-- @alias client
local client = {}

-- event names:

-- "error": function(errmsg, client_object, [packet])
-- on errors
-- optional packet: only if received CONNACK.rc ~= 0 when connecting

-- "close": function(connection_object, client_object)
-- upon closing the connection
-- connection object will have .close_reason (string)

-- "connect": function(packet, client_object)
-- upon a succesful connect, after receiving the CONNACK packet from the broker
-- ???? => on a refused connect; if received CONNACK.rc ~= 0 when connecting

-- "subscribe": function(packet, client_object)
-- upon a succesful subscription, after receiving the SUBACK packet from the broker

-- "unsubscribe": function(packet, client_object)
-- upon a succesful unsubscription, after receiving the UNSUBACK packet from the broker

-- "message": function(packet, client_object)
-- upon receiving a PUBLISH packet from the broker

-- "acknowledge": function(packet, client_object)
-- upon receiving PUBACK
-- upon receiving PUBREC (event fires after sending PUBREL)

-- "auth": function(packet, client_object)
-- upon receiving an AUTH packet

-------

-- load required stuff
local type = type
local error = error
local select = select
local require = require
local tostring = tostring

local os = require("os")
local os_time = os.time

local string = require("string")
local str_format = string.format
local str_gsub = string.gsub
local str_match = string.match

local table = require("table")
local table_remove = table.remove

local math = require("math")
local math_random = math.random

local luamqtt_VERSION

local protocol = require("mqtt.protocol")
local packet_type = protocol.packet_type
local check_qos = protocol.check_qos
local next_packet_id = protocol.next_packet_id
local packet_id_required = protocol.packet_id_required

local protocol4 = require("mqtt.protocol4")
local make_packet4 = protocol4.make_packet
local parse_packet4 = protocol4.parse_packet

local protocol5 = require("mqtt.protocol5")
local make_packet5 = protocol5.make_packet
local parse_packet5 = protocol5.parse_packet

local log = require "mqtt.log"

-------

--- MQTT client instance metatable
-- @type client_mt
local client_mt = {}
client_mt.__index = client_mt

--- Create and initialize MQTT client instance
-- @tparam table opts							MQTT client creation options table
-- @tparam string opts.uri						MQTT broker uri to connect.
--			Expecting "host:port" or "host" format, in second case the port will be selected automatically:
--			1883 port for plain or 8883 for secure network connections
-- @tparam string opts.clean					clean session start flag
-- @tparam[opt=4] number opts.version			MQTT protocol version to use, either 4 (for MQTT v3.1.1) or 5 (for MQTT v5.0).
--												Also you may use special values mqtt.v311 or mqtt.v50 for this field.
-- @tparam[opt] string opts.id					MQTT client ID, will be generated by luamqtt library if absent
-- @tparam[opt] string opts.username			username for authorization on MQTT broker
-- @tparam[opt] string opts.password			password for authorization on MQTT broker; not acceptable in absence of username
-- @tparam[opt=false] boolean,table opts.secure	use secure network connection, provided by luasec lua module;
--			set to true to select default params: { mode="client", protocol="any", verify="none", options={ "all","no_sslv2","no_sslv3","no_tlsv1" }
--			or set to luasec-compatible table, for example with cafile="...", certificate="...", key="..."
-- @tparam[opt] table opts.will					will message table with required fields { topic="...", payload="..." }
--			and optional fields { qos=1...3, retain=true/false }
-- @tparam[opt=60] number opts.keep_alive		time interval for client to send PINGREQ packets to the server when network connection is inactive
-- @tparam[opt=false] boolean opts.reconnect	force created MQTT client to reconnect on connection close.
--			Set to number value to provide reconnect timeout in seconds
--			It's not recommended to use values < 3
-- @tparam[opt] table opts.connector			connector table to open and send/receive packets over network connection.
--			default is require("mqtt.luasocket"), or require("mqtt.luasocket_ssl") if secure argument is set
-- @tparam[opt="ssl"] string opts.ssl_module	module name for the luasec-compatible ssl module, default is "ssl"
--			may be used in some non-standard lua environments with own luasec-compatible ssl module
-- @treturn client_mt MQTT client instance table
function client_mt:__init(opts)
	if not luamqtt_VERSION then
		luamqtt_VERSION = require("mqtt")._VERSION
	end

	-- fetch and validate client opts
	local a = {} -- own client copy of opts

	for key, value in pairs(opts) do
		if type(key) ~= "string" then
			error("expecting string key in opts, got: "..type(key))
		end

		local value_type = type(value)
		if key == "uri" then
			assert(value_type == "string", "expecting uri to be a string")
			a.uri = value
		elseif key == "clean" then
			assert(value_type == "boolean", "expecting clean to be a boolean")
			a.clean = value
		elseif key == "version" then
			assert(value_type == "number", "expecting version to be a number")
			assert(value == 4 or value == 5, "expecting version to be a value either 4 or 5")
			a.version = value
		elseif key == "id" then
			assert(value_type == "string", "expecting id to be a string")
			a.id = value
		elseif key == "username" then
			assert(value_type == "string", "expecting username to be a string")
			a.username = value
		elseif key == "password" then
			assert(value_type == "string", "expecting password to be a string")
			a.password = value
		elseif key == "secure" then
			assert(value_type == "boolean" or value_type == "table", "expecting secure to be a boolean or table")
			a.secure = value
		elseif key == "will" then
			assert(value_type == "table", "expecting will to be a table")
			a.will = value
		elseif key == "keep_alive" then
			assert(value_type == "number", "expecting keep_alive to be a number")
			a.keep_alive = value
		elseif key == "properties" then
			assert(value_type == "table", "expecting properties to be a table")
			a.properties = value
		elseif key == "user_properties" then
			assert(value_type == "table", "expecting user_properties to be a table")
			a.user_properties = value
		elseif key == "reconnect" then
			assert(value_type == "boolean" or value_type == "number", "expecting reconnect to be a boolean or number")
			a.reconnect = value
		elseif key == "connector" then
			a.connector = value
		elseif key == "ssl_module" then
			assert(value_type == "string", "expecting ssl_module to be a string")
			a.ssl_module = value
		else
			error("unexpected key in client opts: "..key.." = "..tostring(value))
		end
	end

	-- check required arguments
	assert(a.uri, 'expecting uri="..." to create MQTT client')
	assert(a.clean ~= nil, "expecting clean=true or clean=false to create MQTT client")
	assert(not a.password or a.username, "password is not accepted in absence of username")

	if not a.id then
		-- generate random client id
		a.id = str_format("luamqtt-v%s-%07x", str_gsub(luamqtt_VERSION, "[^%d]", "-"), math_random(1, 0xFFFFFFF))
	end

	-- default connector
	if a.connector == nil then
		if a.secure then
			a.connector = require("mqtt.luasocket_ssl")
		else
			a.connector = require("mqtt.luasocket")
		end
	end
	-- validate connector content
	assert(type(a.connector) == "table", "expecting connector to be a table")
	assert(type(a.connector.connect) == "function", "expecting connector.connect to be a function")
	assert(type(a.connector.shutdown) == "function", "expecting connector.shutdown to be a function")
	assert(type(a.connector.send) == "function", "expecting connector.send to be a function")
	assert(type(a.connector.receive) == "function", "expecting connector.receive to be a function")
	assert(a.connector.signal_closed, "missing connector.signal_closed signal value")
	assert(a.connector.signal_idle, "missing connector.signal_idle signal value")

	-- will table content check
	if a.will then
		assert(type(a.will.topic) == "string", "expecting will.topic to be a string")
		assert(type(a.will.payload) == "string", "expecting will.payload to be a string")
		if a.will.qos ~= nil then
			assert(type(a.will.qos) == "number", "expecting will.qos to be a number")
			assert(check_qos(a.will.qos), "expecting will.qos to be a valid QoS value")
		end
		if a.will.retain ~= nil then
			assert(type(a.will.retain) == "boolean", "expecting will.retain to be a boolean")
		end
	end

	-- default keep_alive
	if not a.keep_alive then
		a.keep_alive = 60
	end

	-- client opts
	self.opts = a

	-- event handlers
	self.handlers = {
		connect = {},
		subscribe = {},
		unsubscribe = {},
		message = {},
		acknowledge = {},
		error = {},
		close = {},
		auth = {},
	}
	self._handling = {}
	self._to_remove_handlers = {}

	-- state
	self.send_time = 0				-- time of the last network send from client side
	self.first_connect = true		-- contains true to perform one network connection attempt after client creation
									-- Note: remains true, during the connect process. False after succes or failure.

	-- packet creation/parse functions according version
	if not a.version then
		a.version = 4
	end
	if a.version == 4 then
		self._make_packet = make_packet4
		self._parse_packet = parse_packet4
	elseif a.version == 5 then
		self._make_packet = make_packet5
		self._parse_packet = parse_packet5
	end

	log:info("MQTT client '%s' created", a.id)
end

--- Add functions as handlers of given events
-- @param ... (event_name, function) or { event1 = func1, event2 = func2 } table
function client_mt:on(...)
	local nargs = select("#", ...)
	local events
	if nargs == 2 then
		events = { [select(1, ...)] = select(2, ...) }
	elseif nargs == 1 then
		events = select(1, ...)
	else
		error("invalid arguments: expected only one or two arguments")
	end
	for event, func in pairs(events) do
		assert(type(event) == "string", "expecting event to be a string")
		assert(type(func) == "function", "expecting func to be a function")
		local handlers = self.handlers[event]
		if not handlers then
			error("invalid event '"..tostring(event).."' to handle")
		end
		handlers[#handlers + 1] = func
	end
end

-- Remove one item from the list-table with full-iteration
local function remove_item(list, item)
	for i, test in ipairs(list) do
		if test == item then
			table_remove(list, i)
			return
		end
	end
end

--- Remove given function handler for specified event
-- @tparam string event		event name to remove handler
-- @tparam function func	handler function to remove
function client_mt:off(event, func)
	local handlers = self.handlers[event]
	if not handlers then
		error("invalid event '"..tostring(event).."' to handle")
	end
	if self._handling[event] then
		-- this event is handling now, schedule the function removing to the moment after all handlers will be called for the event
		local to_remove = self._to_remove_handlers[event] or {}
		to_remove[#to_remove + 1] = func
		self._to_remove_handlers[event] = to_remove
	else
		-- it's ok to remove given function just now
		remove_item(handlers, func)
	end
	return true
end

--- Subscribe to specified topic. Returns the SUBSCRIBE packet id and calls optional callback when subscription will be created on broker
-- @tparam table opts							subscription options
-- @tparam string opts.topic					topic to subscribe
-- @tparam[opt=0] number opts.qos				QoS level for subscription
-- @tparam boolean opts.no_local				for MQTT v5.0 only: no_local flag for subscription
-- @tparam boolean opts.retain_as_published		for MQTT v5.0 only: retain_as_published flag for subscription
-- @tparam boolean opts.retain_handling			for MQTT v5.0 only: retain_handling flag for subscription
-- @tparam[opt] table opts.properties			for MQTT v5.0 only: properties for subscribe operation
-- @tparam[opt] table opts.user_properties		for MQTT v5.0 only: user properties for subscribe operation
-- @tparam[opt] function opts.callback			callback function to be called when subscription is acknowledged by broker
-- @return packet id on success or false and error message on failure
function client_mt:subscribe(opts)
	-- fetch and validate opts
	assert(type(opts) == "table", "expecting opts to be a table")
	assert(type(opts.topic) == "string", "expecting opts.topic to be a string")
	assert(opts.qos == nil or (type(opts.qos) == "number" and check_qos(opts.qos)), "expecting valid opts.qos value")
	assert(opts.no_local == nil or type(opts.no_local) == "boolean", "expecting opts.no_local to be a boolean")
	assert(opts.retain_as_published == nil or type(opts.retain_as_published) == "boolean", "expecting opts.retain_as_published to be a boolean")
	assert(opts.retain_handling == nil or type(opts.retain_handling) == "boolean", "expecting opts.retain_handling to be a boolean")
	assert(opts.properties == nil or type(opts.properties) == "table", "expecting opts.properties to be a table")
	assert(opts.user_properties == nil or type(opts.user_properties) == "table", "expecting opts.user_properties to be a table")
	assert(opts.callback == nil or type(opts.callback) == "function", "expecting opts.callback to be a function")

	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create SUBSCRIBE packet
	local pargs = {
		type = packet_type.SUBSCRIBE,
		subscriptions = {
			{
				topic = opts.topic,
				qos = opts.qos,
				no_local = opts.no_local,
				retain_as_published = opts.retain_as_published,
				retain_handling = opts.retain_handling
			},
		},
		properties = opts.properties,
		user_properties = opts.user_properties,
	}
	self:_assign_packet_id(pargs)
	local packet_id = pargs.packet_id
	local subscribe = self._make_packet(pargs)

	log:info("subscribing client '%s' to topic '%s' (packet: %s)", self.opts.id, opts.topic, packet_id or "n.a.")

	-- send SUBSCRIBE packet
	local ok, err = self:_send_packet(subscribe)
	if not ok then
		err = "failed to send SUBSCRIBE: "..err
		log:error("client '%s': %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	-- add subscribe callback
	local callback = opts.callback
	if callback then
		local function handler(suback, ...)
			if suback.packet_id == packet_id then
				self:off("subscribe", handler)
				callback(suback, ...)
			end
		end
		self:on("subscribe", handler)
	end

	-- returns assigned packet id
	return packet_id
end

--- Unsubscribe from specified topic, and calls optional callback when subscription will be removed on broker
-- @tparam table opts						subscription options
-- @tparam string opts.topic				topic to unsubscribe
-- @tparam[opt] table opts.properties		properties for unsubscribe operation
-- @tparam[opt] table opts.user_properties	user properties for unsubscribe operation
-- @tparam[opt] function opts.callback		callback function to be called when subscription will be removed on broker
-- @return packet id on success or false and error message on failure
function client_mt:unsubscribe(opts)
	-- fetch and validate opts
	assert(type(opts) == "table", "expecting opts to be a table")
	assert(type(opts.topic) == "string", "expecting opts.topic to be a string")
	assert(opts.properties == nil or type(opts.properties) == "table", "expecting opts.properties to be a table")
	assert(opts.user_properties == nil or type(opts.user_properties) == "table", "expecting opts.user_properties to be a table")
	assert(opts.callback == nil or type(opts.callback) == "function", "expecting opts.callback to be a function")


	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create UNSUBSCRIBE packet
	local  pargs = {
		type = packet_type.UNSUBSCRIBE,
		subscriptions = {opts.topic},
		properties = opts.properties,
		user_properties = opts.user_properties,
	}
	self:_assign_packet_id(pargs)
	local packet_id = pargs.packet_id
	local unsubscribe = self._make_packet(pargs)

	log:info("unsubscribing client '%s' from topic '%s' (packet: %s)", self.opts.id, opts.topic, packet_id or "n.a.")

	-- send UNSUBSCRIBE packet
	local ok, err = self:_send_packet(unsubscribe)
	if not ok then
		err = "failed to send UNSUBSCRIBE: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	-- add unsubscribe callback
	local callback = opts.callback
	if callback then
		local function handler(unsuback, ...)
			if unsuback.packet_id == packet_id then
				self:off("unsubscribe", handler)
				callback(unsuback, ...)
			end
		end
		self:on("unsubscribe", handler)
	end

	-- returns assigned packet id
	return packet_id
end

--- Publish message to broker
-- @tparam table opts						publish operation options table
-- @tparam string opts.topic				topic to publish message
-- @tparam[opt] string opts.payload			publish message payload
-- @tparam[opt=0] number opts.qos			QoS level for message publication
-- @tparam[opt=false] boolean opts.retain	retain message publication flag
-- @tparam[opt=false] boolean opts.dup		dup message publication flag
-- @tparam[opt] table opts.properties		properties for publishing message
-- @tparam[opt] table opts.user_properties	user properties for publishing message
-- @tparam[opt] function opts.callback		callback to call when publihsed message has been acknowledged by the broker
-- @return true or packet id on success or false and error message on failure
function client_mt:publish(opts)
	-- fetch and validate opts
	assert(type(opts) == "table", "expecting opts to be a table")
	assert(type(opts.topic) == "string", "expecting opts.topic to be a string")
	assert(opts.payload == nil or type(opts.payload) == "string", "expecting opts.payload to be a string")
	assert(opts.qos == nil or type(opts.qos) == "number", "expecting opts.qos to be a number")
	if opts.qos then
		assert(check_qos(opts.qos), "expecting qos to be a valid QoS value")
	end
	assert(opts.retain == nil or type(opts.retain) == "boolean", "expecting opts.retain to be a boolean")
	assert(opts.dup == nil or type(opts.dup) == "boolean", "expecting opts.dup to be a boolean")
	assert(opts.properties == nil or type(opts.properties) == "table", "expecting opts.properties to be a table")
	assert(opts.user_properties == nil or type(opts.user_properties) == "table", "expecting opts.user_properties to be a table")
	assert(opts.callback == nil or type(opts.callback) == "function", "expecting opts.callback to be a function")

	-- check connection is alive
	local conn = self.connection
	if not conn then
		return false, "network connection is not opened"
	end

	-- create PUBLISH packet
	opts.type = packet_type.PUBLISH
	self:_assign_packet_id(opts)
	local packet_id = opts.packet_id
	local publish = self._make_packet(opts)

	log:debug("client '%s' publishing to topic '%s' (packet: %s)", self.opts.id, opts.topic, packet_id or "n.a.")

	-- send PUBLISH packet
	local ok, err = self:_send_packet(publish)
	if not ok then
		err = "failed to send PUBLISH: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	-- record packet id as waited for QoS 2 exchange
	if opts.qos == 2 then
		conn.wait_for_pubrec[packet_id] = true
	end

	-- add acknowledge callback
	local callback = opts.callback
	if callback then
		if packet_id then
			local function handler(ack, ...)
				if ack.packet_id == packet_id then
					self:off("acknowledge", handler)
					callback(ack, ...)
				end
			end
			self:on("acknowledge", handler)
		else
			callback("no ack for QoS 0 message", self)
		end
	end

	-- returns assigned packet id
	return packet_id or true
end

--- Acknowledge given received message
-- @tparam packet_mt msg				PUBLISH message to acknowledge
-- @tparam[opt=0] number rc				The reason code field of PUBACK packet in MQTT v5.0 protocol
-- @tparam[opt] table properties		properties for PUBACK/PUBREC packets
-- @tparam[opt] table user_properties	user properties for PUBACK/PUBREC packets
-- @return true on success or false and error message on failure
function client_mt:acknowledge(msg, rc, properties, user_properties)
	assert(type(msg) == "table" and msg.type == packet_type.PUBLISH, "expecting msg to be a publish packet")
	assert(rc == nil or type(rc) == "number", "expecting rc to be a number")
	assert(properties == nil or type(properties) == "table", "expecting properties to be a table")
	assert(user_properties == nil or type(user_properties) == "table", "expecting user_properties to be a table")

	-- check connection is alive
	local conn = self.connection
	if not conn then
		return false, "network connection is not opened"
	end

	-- check packet needs to be acknowledged
	local packet_id = msg.packet_id
	if not packet_id then
		return true
	end

	log:debug("client '%s' acknowledging packet %s", self.opts.id, packet_id or "n.a.")

	if msg.qos == 1 then
		-- PUBACK should be sent

		-- create PUBACK packet
		local puback = self._make_packet{
			type = packet_type.PUBACK,
			packet_id = packet_id,
			rc = rc or 0,
			properties = properties,
			user_properties = user_properties,
		}

		-- send PUBACK packet
		local ok, err = self:_send_packet(puback)
		if not ok then
			err = "failed to send PUBACK: "..err
			log:error("client '%s' %s", self.opts.id, err)
			self:handle("error", err, self)
			self:close_connection("error")
			return false, err
		end
	elseif msg.qos == 2 then
		-- PUBREC should be sent and packet_id should be remembered for PUBREL+PUBCOMP sequence

		-- create PUBREC packet
		local pubrec = self._make_packet{
			type = packet_type.PUBREC,
			packet_id = packet_id,
			rc = rc or 0,
			properties = properties,
			user_properties = user_properties,
		}

		-- send PUBREC packet
		local ok, err = self:_send_packet(pubrec)
		if not ok then
			err = "failed to send PUBREC: "..err
			log:error("client '%s' %s", self.opts.id, err)
			self:handle("error", err, self)
			self:close_connection("error")
			return false, err
		end

		-- store packet id as waiting for PUBREL
		conn.wait_for_pubrel[packet_id] = true
	end

	return true
end

--- Send DISCONNECT packet to the broker and close the connection
-- @tparam[opt=0] number rc				The Disconnect Reason Code value from MQTT v5.0 protocol
-- @tparam[opt] table properties		properties for PUBACK/PUBREC packets
-- @tparam[opt] table user_properties	user properties for PUBACK/PUBREC packets
-- @return true on success or false and error message on failure
function client_mt:disconnect(rc, properties, user_properties)
	-- validate opts
	assert(rc == nil or type(rc) == "number", "expecting rc to be a number")
	assert(properties == nil or type(properties) == "table", "expecting properties to be a table")
	assert(user_properties == nil or type(user_properties) == "table", "expecting user_properties to be a table")

	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create DISCONNECT packet
	local disconnect = self._make_packet{
		type = packet_type.DISCONNECT,
		rc = rc or 0,
		properties = properties,
		user_properties = user_properties,
	}

	log:info("client '%s' disconnecting (rc = %d)", self.opts.id, rc or 0)

	-- send DISCONNECT packet
	local ok, err = self:_send_packet(disconnect)
	if not ok then
		err = "failed to send DISCONNECT: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	-- now close connection
	self:close_connection("connection closed by client")

	return true
end

--- Send AUTH packet to authenticate client on broker, in MQTT v5.0 protocol
-- @tparam[opt=0] number rc				Authenticate Reason Code
-- @tparam[opt] table properties		properties for PUBACK/PUBREC packets
-- @tparam[opt] table user_properties	user properties for PUBACK/PUBREC packets
-- @return true on success or false and error message on failure
function client_mt:auth(rc, properties, user_properties)
	-- validate opts
	assert(rc == nil or type(rc) == "number", "expecting rc to be a number")
	assert(properties == nil or type(properties) == "table", "expecting properties to be a table")
	assert(user_properties == nil or type(user_properties) == "table", "expecting user_properties to be a table")
	assert(self.opts.version == 5, "allowed only in MQTT v5.0 protocol")

	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create AUTH packet
	local auth = self._make_packet{
		type = packet_type.AUTH,
		rc = rc or 0,
		properties = properties,
		user_properties = user_properties,
	}

	log:info("client '%s' authenticating")

	-- send AUTH packet
	local ok, err = self:_send_packet(auth)
	if not ok then
		err = "failed to send AUTH: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	return true
end

--- Immediately close established network connection, without graceful session finishing with DISCONNECT packet
-- @tparam[opt] string reason the reasong string of connection close
function client_mt:close_connection(reason)
	assert(not reason or type(reason) == "string", "expecting reason to be a string")
	local conn = self.connection
	if not conn then
		return true
	end

	reason = reason or "unspecified"

	log:info("client '%s' closing connection (reason: %s)", self.opts.id, reason)

	conn:shutdown()
	self.connection = nil
	conn.close_reason = reason

	self:handle("close", conn, self)
	return true
end

--- Start connecting to broker
-- @return true on success or false and error message on failure
function client_mt:start_connecting()
	-- open network connection
	local ok, err = self:open_connection()
	if not ok then
		self.first_connect = false
		return false, err
	end

	-- send CONNECT packet
	ok, err = self:send_connect()
	if not ok then
		self.first_connect = false
		return false, err
	end

	return true
end

--- Low-level methods
-- @section low-level

--- Send PINGREQ packet
-- @return true on success or false and error message on failure
function client_mt:send_pingreq()
	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create PINGREQ packet
	local pingreq = self._make_packet{
		type = packet_type.PINGREQ,
	}

	log:debug("client '%s' sending PINGREQ", self.opts.id)

	-- send PINGREQ packet
	local ok, err = self:_send_packet(pingreq)
	if not ok then
		err = "failed to send PINGREQ: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	-- set ping timeout; for now 1 ping-request interval
	self.ping_expire_time = os_time() + self.opts.keep_alive

	return true
end

--- Open network connection to the broker
-- @return true on success or false and error message on failure
function client_mt:open_connection()
	if self.connection then
		return true
	end

	local opts = self.opts
	local connector = assert(opts.connector, "no connector configured in MQTT client")

	-- create connection table
	local conn = setmetatable({
		uri = opts.uri,
		wait_for_pubrec = {},	-- a table with packet_id of partially acknowledged sent packets in QoS 2 exchange process
		wait_for_pubrel = {},	-- a table with packet_id of partially acknowledged received packets in QoS 2 exchange process
	}, connector)
	client_mt._parse_uri(opts, conn)
	client_mt._apply_secure(opts, conn)

	log:info("client '%s' connecting to broker '%s' (using: %s)", self.opts.id, opts.uri, conn.type or "unknown")

	-- perform connect
	local ok, err = conn:connect()
	if not ok then
		log:error("client '%s' %s", self.opts.id, err)
		err = "failed to open network connection: "..err
		self:handle("error", err, self)
		return false, err
	end

	-- assign connection
	self.connection = conn

	-- reset ping timeout
	self.ping_expire_time = nil

	return true
end

--- Send CONNECT packet into opened network connection
-- @return true on success or false and error message on failure
function client_mt:send_connect()
	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	local opts = self.opts

	-- create CONNECT packet
	local connect = self._make_packet{
		type = packet_type.CONNECT,
		id = opts.id,
		clean = opts.clean,
		username = opts.username,
		password = opts.password,
		will = opts.will,
		keep_alive = opts.keep_alive,
		properties = opts.properties,
		user_properties = opts.user_properties,
	}

	log:info("client '%s' sending CONNECT (user '%s')", self.opts.id, opts.username or "not specified")

	-- send CONNECT packet
	local ok, err = self:_send_packet(connect)
	if not ok then
		err = "failed to send CONNECT: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	-- reset last packet id
	self._last_packet_id = nil

	return true
end

--- Checks last message send, and sends a PINGREQ if necessary.
-- Use this function to check and send keep-alives when using an external event loop.
-- @return time till next keep_alive, in case of errors (eg. not connected) the second return value is an error string
-- @usage
-- -- example using a Copas event loop to send and check keep-alives
-- copas.addthread(function()
--     while true do
--         if not my_client then
--             return -- exiting, client was destroyed
--         end
--         copas.sleep(my_client:check_keep_alive())
--     end
-- end)
function client_mt:check_keep_alive()
	local interval = self.opts.keep_alive
	if not self.connection then
		return interval, "network connection is not opened"
	end

	local t_now = os_time()
	local t_next = self.send_time + interval
	local t_timeout = self.ping_expire_time

	-- check last ping request
	if t_timeout and t_timeout <= t_now then
		-- we timed-out, close and exit
		local err = str_format("failed to receive PINGRESP within %d seconds", interval)
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return interval, err
	end

	-- send PINGREQ if keep_alive interval is reached
	if t_now >= t_next then
		local _, err = self:send_pingreq()
		return interval, err
	end

	-- return which ever is earlier, timeout or next ping request
	if t_timeout and t_timeout < t_next then
		return t_timeout - t_now
	end
	return t_next - t_now
end


-- Internal methods

-- Send PUBREL acknowledge packet - second phase of QoS 2 exchange
-- Returns true on success or false and error message on failure
function client_mt:acknowledge_pubrel(packet_id)
	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create PUBREL packet
	local pubrel = self._make_packet{type=packet_type.PUBREL, packet_id=packet_id, rc=0}

	log:debug("client '%s' sending PUBREL (packet: %s)", self.opts.id, packet_id or "n.a.")

	-- send PUBREL packet
	local ok, err = self:_send_packet(pubrel)
	if not ok then
		err = "failed to send PUBREL: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	return true
end

-- Send PUBCOMP acknowledge packet - last phase of QoS 2 exchange
-- Returns true on success or false and error message on failure
function client_mt:acknowledge_pubcomp(packet_id)
	-- check connection is alive
	if not self.connection then
		return false, "network connection is not opened"
	end

	-- create PUBCOMP packet
	local pubcomp = self._make_packet{type=packet_type.PUBCOMP, packet_id=packet_id, rc=0}

	log:debug("client '%s' sending PUBCOMP (packet: %s)", self.opts.id,  packet_id or "n.a.")

	-- send PUBCOMP packet
	local ok, err = self:_send_packet(pubcomp)
	if not ok then
		err = "failed to send PUBCOMP: "..err
		log:error("client '%s' %s", self.opts.id, err)
		self:handle("error", err, self)
		self:close_connection("error")
		return false, err
	end

	return true
end

-- Call specified event handlers
function client_mt:handle(event, ...)
	local handlers = self.handlers[event]
	if not handlers then
		error("invalid event '"..tostring(event).."' to handle")
	end
	self._handling[event] = true -- protecting self.handlers[event] table from modifications by client_mt:off() when iterating
	for _, handler in ipairs(handlers) do
		handler(...)
	end
	self._handling[event] = nil

	-- process handlers removing, scheduled by client_mt:off()
	local to_remove = self._to_remove_handlers[event]
	if to_remove then
		for _, func in ipairs(to_remove) do
			remove_item(handlers, func)
		end
		self._to_remove_handlers[event] = nil
	end
end

-- Internal methods

-- Assign next packet id for given packet creation opts
function client_mt:_assign_packet_id(pargs)
	if not pargs.packet_id then
		if packet_id_required(pargs) then
			self._last_packet_id = next_packet_id(self._last_packet_id)
			pargs.packet_id = self._last_packet_id
		end
	end
end

-- Handle a single received packet
function client_mt:handle_received_packet(packet)
	local conn = self.connection
	local err

	log:debug("client '%s' received '%s' (packet: %s)", self.opts.id, packet_type[packet.type], packet.packet_id or "n.a.")

	if not conn.connack then
		-- expecting only CONNACK packet here
		if packet.type ~= packet_type.CONNACK then
			err = "expecting CONNACK but received "..packet.type
			log:error("client '%s' %s", self.opts.id, err)
			self:handle("error", err, self)
			self:close_connection("error")
			self.first_connect = false
			return false, err
		end

		-- store connack packet in connection
		conn.connack = packet

		-- check CONNACK rc
		if packet.rc ~= 0 then
			err = str_format("CONNECT failed with CONNACK [rc=%d]: %s", packet.rc, packet:reason_string())
			log:error("client '%s' %s", self.opts.id, err)
			self:handle("error", err, self, packet)
			self:handle("connect", packet, self)
			self:close_connection("connection failed")
			self.first_connect = false
			return false, err
		end

		log:info("client '%s' connected successfully to '%s:%s'", self.opts.id, conn.host, conn.port)

		-- fire connect event
		self:handle("connect", packet, self)
		self.first_connect = false
	else
		-- connection authorized, so process usual packets

		-- handle packet according its type
		local ptype = packet.type
		if ptype == packet_type.PINGRESP then -- luacheck: ignore
			-- PINGREQ answer, clear timeout
			self.ping_expire_time = nil
		elseif ptype == packet_type.SUBACK then
			self:handle("subscribe", packet, self)
		elseif ptype == packet_type.UNSUBACK then
			self:handle("unsubscribe", packet, self)
		elseif ptype == packet_type.PUBLISH then
			-- check such packet is not waiting for pubrel acknowledge
			self:handle("message", packet, self)
		elseif ptype == packet_type.PUBACK then
			self:handle("acknowledge", packet, self)
		elseif ptype == packet_type.PUBREC then
			local packet_id = packet.packet_id
			if conn.wait_for_pubrec[packet_id] then
				conn.wait_for_pubrec[packet_id] = nil
				-- send PUBREL acknowledge
				if self:acknowledge_pubrel(packet_id) then
					-- and fire acknowledge event
					self:handle("acknowledge", packet, self)
				end
			end
		elseif ptype == packet_type.PUBREL then
			-- second phase of QoS 2 exchange - check we are already acknowledged such packet by PUBREL
			local packet_id = packet.packet_id
			if conn.wait_for_pubrel[packet_id] then
				-- remove packet from waiting for PUBREL packets table
				conn.wait_for_pubrel[packet_id] = nil
				-- send PUBCOMP acknowledge
				return self:acknowledge_pubcomp(packet_id)
			end
		elseif ptype == packet_type.PUBCOMP then --luacheck: ignore
			-- last phase of QoS 2 exchange
			-- do nothing here
		elseif ptype == packet_type.DISCONNECT then
			self:close_connection("disconnect received from broker")
		elseif ptype == packet_type.AUTH then
			self:handle("auth", packet, self)
		else
			log:warn("client '%s' don't know how to handle %s", self.opts.id, ptype)
		end
	end
	return true
end

do
	-- implict (re)connecting when reading
	local function implicit_connect(self)
		local opts = self.opts

		if not self.first_connect and not opts.reconnect then
			-- this would be a re-connect, but we're not supposed to auto-reconnect
			log:debug("client '%s' was disconnected and not set to auto-reconnect", self.opts.id)
			return false, "network connection is not opened"
		end

		-- should we wait for a timeout between retries?
		local t_reconnect = (self.last_connect_time or 0) + (opts.reconnect or 0)
		local t_now = os_time()
		if t_reconnect > t_now then
			-- were delaying before retrying, return remaining delay
			return t_reconnect - t_now
		end

		self.last_connect_time = t_now

		local ok, err = self:start_connecting()
		if not ok then
			-- we failed to connect
			if opts.reconnect then
				-- set to auto-reconnect, report the configured retry delay
				return opts.reconnect
			end
			-- not reconnecting, so just report the error
			return ok, err
		end

		-- connected succesfully, but don't know how long it took, so return now
		-- to be nice to other clients. Return 0 to indicate ready-for-reading.
		return 0
	end

	--- Performs a single IO loop step.
	-- It will connect if not connected, will re-connect if set to.
	-- This should be called repeatedly in a loop.
	--
	-- The return value is the time after which this method must be called again.
	-- It can be called sooner, but shouldn't be called later. Return values:
	--
	-- - `0`; a packet was succesfully handled, so retry immediately, no delays,
	--   in case additional data is waiting to be read on the socket.
	-- - `>0`; The reconnect timer needs a delay before it can retry (calling
	--   sooner is not a problem, it will only reconnect when the delay
    --   has actually passed)
	-- - `-1`; the socket read timed out, so it is idle. This return code is only
	--   returned with buffered connectors (luasocket), never for yielding sockets
	--   (Copas or OpenResty)
	--
	-- @return time after which to retry or nil+error
	function client_mt:step()
		local conn = self.connection

		-- try and connect if not connected yet
		if not conn then
			return implicit_connect(self)
		end

		local packet, err = self:_receive_packet()
		if not packet then
			if err == conn.signal_idle then
				-- connection was idle, nothing happened
				return -1
			elseif err == conn.signal_closed then
				self:close_connection("connection closed by broker")
				return false, err
			else
				err = "failed to receive next packet: "..tostring(err)
				log:error("client '%s' %s", self.opts.id, err)
				self:handle("error", err, self)
				self:close_connection("error")
				return false, err
			end
		end

		local ok
		ok, err = self:handle_received_packet(packet)
		if not ok then
			if not self.opts.reconnect then
				-- no auto-reconnect, so return error
				return ok, err
			else
				-- reconnect, return 0 to retry asap, the reconnect code
				-- will then do the right-thing TM
				return 0
			end
		end

		-- succesfully handled packed, maybe there is more, so retry asap
		return 0
	end
end

-- Fill given connection table with host and port according given opts
function client_mt._parse_uri(opts, conn)
	local host, port = str_match(opts.uri, "^([^%s]+):(%d+)$")
	if not host then
		-- trying pattern without port
		host = assert(str_match(conn.uri, "^([^%s]+)$"), "invalid uri format: expecting at least host/ip in .uri")
	end
	if not port then
		if opts.secure then
			port = 8883 -- default MQTT secure connection port
		else
			port = 1883 -- default MQTT connection port
		end
	else
		port = tonumber(port)
	end
	conn.host, conn.port = host, port
end

-- Creates the conn.secure_params table and its content according client creation opts
function client_mt._apply_secure(opts, conn)
	local secure = opts.secure
	if secure then
		conn.secure = true
		if type(secure) == "table" then
			conn.secure_params = secure
		else
			conn.secure_params = {
				mode = "client",
				protocol = "any",
				verify = "none",
				options = {"all", "no_sslv2", "no_sslv3", "no_tlsv1"},
			}
		end
		conn.ssl_module = opts.ssl_module or "ssl"
	end
end

-- Send given packet to opened network connection
function client_mt:_send_packet(packet)
	local conn = self.connection
	if not conn then
		return false, "network connection is not opened"
	end
	local data = tostring(packet)
	local len = data:len()
	if len <= 0 then
		return false, "sending empty packet"
	end
	-- and send binary packet to network connection
	local ok, err = conn:send(data)
	if not ok then
		return false, "connector.send failed: "..err
	end
	self.send_time = os_time()
	return true
end

-- Receive one packet from established network connection
function client_mt:_receive_packet()
	local conn = self.connection
	if not conn then
		return false, "network connection is not opened"
	end
	-- read & parse packet
	local packet, err = self._parse_packet(
		function(size)
			return conn:receive(size)
		end
	)
	if packet then
		-- succesful packet, clear handled data and return it
		conn:buffer_clear()
		return packet
	end

	-- check if we need more data, if not, clear the buffer because were done with
	-- the data in that case
	if err == conn.signal_idle then
		-- we need more data, so do not clear buffer, just return the error
		return false, err
	end

	-- some other error, can't use buffered data, dispose of it
	conn:buffer_clear()
	return false, err
end

-- Represent MQTT client as string
function client_mt:__tostring()
	return str_format("mqtt.client{id=%q}", tostring(self.opts.id))
end

-- Garbage collection handler
function client_mt:__gc()
	-- close network connection if it's available, without sending DISCONNECT packet
	if self.connection then
		self:close_connection("garbage")
	end
end

--- Exported functions
-- @section exported

--- Create, initialize and return new MQTT client instance
-- @param ... see arguments of client_mt:__init(opts)
-- @see client_mt:__init
-- @treturn client_mt MQTT client instance
function client.create(...)
	local cl = setmetatable({}, client_mt)
	cl:__init(...)
	return cl
end

-------

-- export module table
return client

-- vim: ts=4 sts=4 sw=4 noet ft=lua
